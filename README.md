# Собственный фейковый REST API сервер с поддержкой CRUD

## Summary

При изучении HTTP-запросов мы использовали сервисы с фейковым API. Сейчас же мы создадим свой собственный. В нем будет поддержка всех четырех операций CRUD.

После того как приложение станет готово в ней должна быть поддержка следующих роутов:

| Ресурс | Назначение |
| --- | --- |
| `GET /:key` | Получение содержимого ключа `:key` |
| `GET /:key/:id` | Получение одного элемента из ключа `:key`, у которого `id` равен `:id` |
| `POST /:key` | Добавление нового элемента в конец ключа `:key` |
| `DELETE /:key/:id` | Удаление элемента из свойства `:key`, у которого айди равен указанному в `:id` |
| `PATCH /:key/:id` | Изменение значения ключей (будут указаны в теле запроса) |

В качестве базы данных будет выступать файл `database.json`.

### Пример

Допустим, в файле `database.json` следующее содержимое:

```json
{
  "users": [
    {
      "id": 1,
      "name": "Адам"
    },
    {
      "id": 2,
      "name": "Дени"
    },
    {
      "id": 3,
      "name": "Хамза"
    }
  ],

  "words": [
    {
      "id": 1,
      "word": "intocode"
    },
    {
      "id": 2,
      "word": "javascript"
    },
    {
      "id": 3,
      "word": "fileSystem"
    },
    {
      "id": 4,
      "word": "require"
    }
  ]
}
```

---

**Запрос `GET /users` должен будет вернуть массив**

```json
[
  {
    "id": 1,
    "name": "Адам"
  },
  {
    "id": 2,
    "name": "Дени"
  },
  {
    "id": 3,
    "name": "Хамза"
  }
]
```

---

**Запрос `GET /users/2` должен будет вернуть объект**

```json
{
  "id": 2,
  "name": "Дени"
}
```

---

**Запрос `POST /users`, у которого тело равно `{ "name": "kuduzow" }` должно будет добавить в массив нового юзера (определив ему новый `id`) и сохранить его в файл `database.json`**

```json
[
  {
    "id": 1,
    "name": "Адам"
  },
  {
    "id": 2,
    "name": "Дени"
  },
  {
    "id": 3,
    "name": "Хамза"
  },
  {
    "id": 4,
    "name": "kuduzow"
  }
]
```

---

**Запрос `DELETE /words/1` должен удалить элемент из массива `words` у которого `id` равен `1`**

---

**Запрос `PATCH /words/2`, тело которого равно `{ "word": "new word" }` должен заменить массив `words` на следующий**

```json
[
  {
    "id": 1,
    "word": "intocode"
  },
  {
    "id": 2,
    "word": "new word"
  },
  {
    "id": 3,
    "word": "fileSystem"
  },
  {
    "id": 4,
    "word": "require"
  }
]
```

---

Помимо `words` или `users` в файле могут быть и другие ключи.

## Подготовка к разработке

Для реализации приложения предлагается использовать следующий подход:

1) с помощью функций из `fs` получать содержимое файла `database.json` и преобразовывать в объект с помощью `JSON.parse()`
2) работать с получившимся объектом стандартными способами JS (добавлять что-то, удалять и т.д.)
3) после обработки новое значение обратно сохранять в файл `database.json`.

## Releases

### Release 0: предусматриваем проблемы

#### Проблема 1

Клиент в своих запросах обращается к серверу по `id`, а не по индексу. При этом функции для добавления, извлечения, удаления и т.д. требуют указать индекс элемента.

Напиши функцию `getIndexById()`, которая принимает два параметра – массив из объектов и `id`. Функция должна вернуть индекс элемента, id которого равен указанному в параметре.

Если объект с таким `id` не найден, то функция должна вернуть `-1`.

```javascript
function getIndexById (collection, id) {
  // твой код
}
```

#### Проблема 2

При добавлении новых значений в конец массива нужно будет автоматически генерировать новое значение `id`, которое будет на единицу больше самого большого значения из старых записей.

Для этого напиши функцию `getNextId()`, которая принимает в качестве параметра массив из объектов и возвращает самое большое найденное значение для `id` увеличенное на единицу. Если массив из параметра пустой, то верни `1`. 

```javascript
function getNextId (collection) {
  // твой код
}
```

#### Проблема 3

Так как запросы могут содержать либо не содержать в себе последнюю часть с указанием `id`, то нужно написать функцию, которая позволяет это определять, чтобы выдать клиенту только нужные ему данные.

Например:

```
GET /users        <- клиенту нужны все пользователи
GET /users/2      <- клиенту нужен только пользователь с id === 2
```

Напиши функцию `parseQuery()`, которая принимает строку в качестве параметра. Этой строкой будет ~~Альберт Эйнштейн~~ значение из `req.url`.

Функция должна вернуть объект, в котором будет два ключа: `resource` и `id` с соответствующими значениями. Если `id` в запросе не указан, то значение свойства `id` должно быть `null`.

Пример работы функции:

```javascript
parseQuery('/users') // должна вернуть объект { resource: "users", id: null }
parseQuery('/words') // должна вернуть объект { resource: "words", id: null }
parseQuery('/messages/100') // должна вернуть объект { resource: "messages", id: 100 }
parseQuery('/words/5') // должна вернуть объект { resource: "words", id: 5 }
```

---

Вынеси эти функции в файл `functions.js` и экспортируй с помощью `module.exports`.

### Release 1. Минимальный сервер

Напиши минимальный сервер используя модуль `http`.

### Release 2. Read

Приступая к реализации CRUD напиши часть сервера, которая позволяет читать данные из нашей БД.

Определи метод запроса. Если он равен `GET`, то сделай парсинг `req.url` с помощью функции `parseQuery()`. В зависимости от результата парсинга выдай клиенту нужные данные.

Проверь правильность работы сервера с помощью Postman.

### Release 3. DELETE

Определи метод запроса. Если он равен `DELETE`, то удали из файла `database.json` указанный ресурс.

> **Алгоритм изменения базы данных (database.json)**
> 
> Так как в nodejs нет встроенных методов для редактирования .json-файла, то алгоритм редактирования должен сводиться к следующим шагам:
> 
> 1) извлекаем содержимое файла с помощью `fs.readFile()`
> 2) парсим содержимое с помощью `JSON.parse()`. После парсинга с данными можно будет работать как с обычным JavaScript-объектом
> 3) вносим нужные изменения в этот объект. После изменений преобразовываем объект обратно в строку с помощью `JSON.stringify()`
> 4) перезаписываем файл `database.json` с помощью `fs.writeFile()`. В качестве данных для добавления указываем строку из пункта 3.
> 
> Данный алгоритм актуален для любых изменений: добавление новых значений, удаления или редактирования старых.

### Release 4. POST & PATCH

Имея на руках алгоритм и опыт разработки предыдущих релизов сделай возможность добавления и изменения данных из нашей БД.

### Release 5. Code refactoring

Сделай код-ревью своего проекта. Определи все слабые места в коде.

Самой важной задачей является избавление от повторов кода. Лучший способ это сделать – вынести повторяющийся код в отдельные функции.

## Заключение

Как всегда самой важной частью задания является твоё умение повторить все релизы без подсматривания в старый код. 

Хотя бы один раз перевыполни данное задание не подглядывая в старый код.

Инициализируй git, сделай коммит и выгрузи готовый проект в свой GitHub. Скорее всего текущий челлендж попадет в твоё портфолио😋
